{"name":"SRST2","tagline":"Short Read Sequence Typing for Bacterial Pathogens","body":"SRST2\r\n====\r\n\r\nShort Read Sequence Typing for Bacterial Pathogens\r\n\r\nThis program is designed to take Illumina sequence data, a MLST database and/or a database\r\nof gene sequences (e.g. resistance genes, virulence genes, etc) and report the presence of\r\nSTs and/or reference genes.\r\n\r\n\r\n\r\nDependencies:\r\n\r\npython (v2.7.5), scipy\r\n\r\nbowtie2 v2.1.0     http://bowtie-bio.sourceforge.net/bowtie2/index.shtml\r\n\r\nSAMtools v0.1.18   https://sourceforge.net/projects/samtools/files/samtools/0.1.18/ (NOTE 0.1.19 DOES NOT WORK)\r\n\r\n\r\n\r\nAuthors - Michael Inouye, Harriet Dashnow, Bernie Pope, Kathryn Holt (University of Melbourne)\r\n\t\t\r\nHow to cite - Please check back for news on the paper. In the meantime, please cite \"SRST2 - Short Read Sequence Typing for Bacterial Pathogens, http://katholt.github.io/srst/\"\r\n\t\t\r\nProblems? - Email drkatholt@gmail.com. For updates, join the srst2 google group https://groups.google.com/forum/#!forum/srst2.\r\n\r\n\r\nInstallation\r\n====\r\n1 - Install dependencies first\r\n\r\n2 - Download the zip or tarball at the top left of this page and unpack it\r\n\r\n3 - Install using pip (http://www.pip-installer.org/) or easy_install\r\n\r\nYou may need to use sudo to install centrally:\r\n\r\n    pip install srst2-0.1.0-beta/\r\n\r\nOR\r\n\r\n    easy_install srst2-0.1.0-beta/\r\n\r\n4 - Test that the programs are installed properly\r\n\r\n    srst2 --version\r\n\r\n    getmlst.py -h\r\n\r\n    scores_vs_expected.py -h\r\n\r\n    slurm_srst2.py -h\r\n\r\nThe downloaded directory also contains things that might be useful for srst2 users:\r\n\r\ndata/resistance.fasta contains a preliminary resistance sequence database that can be used for identifying resistance genes\r\n\r\ndatabase_clustering/ contains scripts and instructions for formatting of gene databases for use with srst2\r\n\r\nexample.txt contains a tutorial/example on running srst2 using public data\r\n\r\n\r\nBasic usage - MLST\r\n====\r\n\r\n1 - Gather your input files:\r\n\r\n(i) sequence reads (this example uses paired reads in gzipped fastq format, see below for options)\r\n\r\n(ii) a fasta sequence database to match to. For MLST, this means a fasta file of all allele sequences. If you want to assign STs, you also need a tab-delim file which defines the ST profiles as a combination of alleles. You can retrieve these files automatically from pubmlst.org/data/ using the script provided:\r\n\r\ngetmlst.py --species \"Escherichia coli\"\r\n\r\n2 - Run MLST:\r\n\r\nsrst2 --input_pe strainA_1.fastq.gz strainA_2.fastq.gz --output strainA_test --log \r\n\t--mlst_db Escherichia_coli.fasta --mlst_definitions ecoli.txt\r\n\r\n3 - Check the outputs:\r\n\r\n(i) MLST results are output in: \"strainA_test__mlst__Escherichia_coli__results.txt\"\r\n\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth\r\n\r\nstrainA     152     11      63      7       1       14      7       7                       25.8319955826\r\n```\r\n\r\nBasic usage - Resistance genes\r\n====\r\n\r\n1 - Gather your input files:\r\n\r\n(i) sequence reads (this example uses paired reads in gzipped fastq format, see below for options)\r\n\r\n(ii) a fasta sequence database to match to. For resistance genes, this means a fasta file of all the resistance genes/alleles that you want to screen for, clustered into gene groups. A suitable database, which combines sequences from ResFinder and CARD, is distributed with SRST2 (data/resistance.fasta).\r\n\r\n2 - Run gene detection:\r\n\r\nsrst2 --input_pe strainA_1.fastq.gz strainA_2.fastq.gz --output strainA_test --log --gene_db resistance.fasta\r\n\r\n3 - Check the outputs:\r\n\r\n(i) Gene detection results are output in: \"strainA_test__genes__resistance__results.txt\"\r\n\r\n```\r\nSample  aadA    dfrA    sul2    tet(B)\r\n\r\nstrainA     aadA1-5 dfrA1_1 sul2_2  tet(B)_4\r\n```\r\n\r\nAll usage options\r\n====\r\n\r\n```\r\nsrst2 -h\r\n\r\nSRST2 - Short Read Sequence Typer (v2)\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n\r\n  --version             show version number and exit \r\n  \r\n  --input_se INPUT_SE [INPUT_SE ...]\r\n                        Single end read file(s) for analysing (may be gzipped)\r\n                        \r\n  --input_pe INPUT_PE [INPUT_PE ...]\r\n                        Paired end read files for analysing (may be gzipped)\r\n                        \r\n  --forward FORWARD     Designator for forward reads (only used if NOT in\r\n                        MiSeq format sample_S1_L001_R1_001.fastq.gz; otherwise\r\n                        default is _1, i.e. expect forward reads as\r\n                        sample_1.fastq.gz)\r\n                        \r\n  --reverse REVERSE     Designator for reverse reads (only used if NOT in\r\n                        MiSeq format sample_S1_L001_R2_001.fastq.gz; otherwise\r\n                        default is _2, i.e. expect forward reads as\r\n                        sample_2.fastq.gz)\r\n                        \r\n  --read_type {q,qseq,f}\r\n                        Read file type (for bowtie2; default is q=fastq; other\r\n                        options: qseq=solexa, f=fasta)\r\n                        \r\n  --mlst_db MLST_DB     Fasta file of MLST alleles (optional)\r\n  \r\n  --mlst_delimiter MLST_DELIMITER\r\n                        Character(s) separating gene name from allele number\r\n                        in MLST database (default \"-\", as in arcc-1)\r\n                        \r\n  --mlst_definitions MLST_DEFINITIONS\r\n                        ST definitions for MLST scheme (required if mlst_db\r\n                        supplied and you want to calculate STs)\r\n                        \r\n  --gene_db GENE_DB [GENE_DB ...]\r\n                        Fasta file/s for gene databases (optional)\r\n                        \r\n  --no_gene_details     Switch OFF verbose reporting of gene typing\r\n                                                \r\n  --min_coverage MIN_COVERAGE\r\n                        Percent coverage cutoff for gene reporting (default\r\n                        90)\r\n                        \r\n  --min_depth MIN_DEPTH\r\n                        Minimum mean depth to flag as dubious allele call\r\n                        (default 5)\r\n                        \r\n  --min_edge_depth MIN_EDGE_DEPTH\r\n                        Minimum edge depth to flag as dubious allele call\r\n                        (default 2)\r\n                        \r\n  --prob_err PROB_ERR   Probability of sequencing error (default 0.01)\r\n                        \r\n  --other OTHER         Other arguments to pass to bowtie2\r\n  \r\n  --mapq MAPQ           Samtools -q parameter (default 1)\r\n  \r\n  --baseq BASEQ         Samtools -Q parameter (default 20)\r\n  \r\n  --output OUTPUT       Output file prefix\r\n  \r\n  --log            \tSwitch ON logging to file (otherwise log to stdout)\r\n  \r\n  --save_scores         Switch ON verbose reporting of all scores\r\n  \r\n  --use_existing_pileup\r\n                        Use existing pileups if available, otherwise they will\r\n                        be generated\r\n                        \r\n  --use_existing_scores\r\n                        Use existing scores files if available, otherwise they\r\n                        will be generated\r\n                        \r\n  --prev_output PREV_OUTPUT [PREV_OUTPUT ...]\r\n                        SRST2 results files to compile (any new results from\r\n                        this run will also be incorporated)\r\n```\r\n\r\nInput read formats and options\r\n====\r\n\r\nAny number of readsets can be provided using --input_se (for single end reads) and/or --input_pe (for paired end reads). You can provide both types of reads at once. Note however that if you do this, each readset will be typed one by one (in serial). So if it takes 2 minutes to type each read set, and you provide 10 read sets, it will take 20 minutes to get your results. The better way to proces lots of samples quickly is to give each one its own srst2 job (e.g. submitted simultaneously to your job scheduler or server); then compile the results into a single report using \"srst2 --prev_output *results.txt --output all\". That way each readset's 2 minutes of analysis is occurring in parallel on different nodes, and you'll get your results for all 10 samples in 2 minutes rather than 20.\r\n\r\n### Read formats \r\nReads can be in any format readable by bowtie2. The format is passed on to the bowtie2 command via the --read_type flag in srst2. The default format is fastq (passed to bowtie 2 as q); other options are qseq=solexa, f=fasta. So to use fasta reads, you would need to tell srst2 this via '--read_type f'.\r\n\r\nReads may be gzipped.\r\n\r\n### Read names \r\nSrst2 can parse Illumina MiSeq reads files; we assume that files with names in the format 'XXX_S1_L001_R1_001.fastq.gz' and 'XXX_S1_L001_R2_001.fastq.gz' are the forward and reverse reads from a sample named 'XXX'. So, you can simply use 'srst2 --input_pe XXX_S1_L001_R1_001.fastq.gz XXX_S1_L001_R2_001.fastq.gz' and srst2 will recognise these as forward and reverse reads of a sample named XXX. If you have single rather than paired MiSeq reads, you would use 'srst2 --input_se XXX_S1_L001_R1_001.fastq.gz'.\r\n\r\n### Paired reads\r\nIf you have paired reads that are named in some way other than the Illumina MiSeq format, e.g. from the SRA or ENA public databases, you need to tell srst2 how to pass these to bowtie2.\r\nbowtie2 requires forward and reverse reads to be supplied in separate files, e.g strainA_1.fastq.gz and strainA_2.fastq.gz. srst2 attempts to sort reads supplied via --input_pe into read pairs, based on the suffix (_1, _2 in this example) that occurs before the file extension (.fastq.gz in this example). So if you supplied --input_pe strainA_1.fastq.gz strainB_1.fastq.gz strainA_2.fastq.gz strainB_2.fastq.gz, srst2 would sort these into two pairs (strainA_1.fastq.gz, strainA_2.fastq.gz) and (strainB_1.fastq.gz, strainB_2.fastq.gz) and pass each pair on to bowtie2 for mapping. By default, the suffixes are assumed to be \"_1\" for forward reads and \"_2\" for reverse reads, but you can tell srst2 if you have other conventions, via --forward and --reverse. E.g. if your files were named strainA_read1.fastq.gz and strainA_read2.fastq.gz, you would use these commands: --input_pe strainA_read1.fastq.gz strainA_read2.fastq.gz --forward _read1 --reverse _read2. \r\n\r\n### Sample names\r\nSample names are taken from the first part of the read file name (before the suffix if you have paired reads). E.g. 'strainA_1.fastq.gz' is assumed to belong to a sample called \"strainA\"; 'strainB_C_1.fastq.gz\" would be assumed to belong to a sample called \"strainB_C\". These sample names will be used to name all output files, and will appear in the results files.\r\n\r\n\r\nMLST Database format\r\n====\r\nMLST databases are specified by allele sequences, and a profiles table. These can be downloaded from the public databases, ready to use with srst2, using the provided script getmlst.py (see above).\r\n\r\n### Allele sequences file, fasta format. \r\n\r\n--mlst_db alleles.fasta\r\n\r\nThis should contain ALL allele sequences for the MLST scheme; i.e. if there are 7 loci in the scheme, then the sequences of all alleles from all 7 loci should appear together in this file. If you have one file per locus, just cat these together first. If you use getmlst.py, this is done for you.\r\n\r\n--mlst_delimiter '-'\r\n\r\nThe names of the alleles (i.e. the fasta headers) are critical for a functioning MLST scheme and therefore for correct calling of STs. There are two key components to every fasta header: the name of the locus (e.g. in E. coli these are adk, fumC, gyrB, icd, mdh, purA, recA) and the number assigned to the allele (1, 2, 3 etc). These are usually separated by a delimiter like '-' or '_'; e.g. in the E. coli scheme, alleles are named adk-1, fumC-10, etc. For ST calling to work properly, srst2 needs to know what the delimiter is. By default, we assume it is '-' as this is the most common; however some schemes use '_' (e.g. in the C. difficile scheme, the first allele is 'adk_1', so you would need to set --mlst_delimiter '_' on the srst2 command line). If you use getmlst.py, it will remind you of this and try to guess for you what the most likely delimiter is.\r\n\r\n### MLST definitions file, tab delimited format.\r\n\r\n--mlst_definitions\r\n\r\nThis is the file that tells you the ST number that is assigned to known combinations of alleles. Column 1 is the ST, and subsequent columns are the loci that make up the scheme. The names of these loci must match the allele names in the sequences database, e.g. adk, fumC, gyrB, icd, mdh, purA, recA in the E. coli scheme. If you download data from pubmlst this should not be a problem. Sometimes there are additional columns in this file, e.g. a column assigning STs to clonal complexes. srst2 will ignore any columns that don't match gene names found in the allele sequences file.\r\n\r\nGene databases\r\n====\r\n\r\nIn addition to MLST, srst2 can do gene/allele detection. This works by mapping reads to each of the reference sequences in a fasta file(s) (provided through --gene_db) and reporting details of all genes that are covered above a certain level (--min_coverage, 90% by default). \r\n\r\nIf the input database contains different alelles of the same gene, srst2 can report just the best matching allele for that gene (much like with MLST we report the best matching allele for each locus in the scheme). This makes the output manageable, as you will get one column per gene/locus (e.g. blaCTX-M) which reports the specific allele that was called in each sample (e.g. blaCTX-M-15 in sample A, blaCTX-M-13 in sample B).\r\n\r\nWe have provided a preliminary set of resistance genes in the /data directory of srst2, this is based on the ResFinder database and CARD. The fasta file (data/resistance.fasta) is ready for use with srst2.\r\n\r\nYou can however format any sequence set for screening with srst2. See instructions at the bottom of this page.\r\n\r\nOutput files\r\n====\r\n\r\n### MLST results\r\n\r\nIf MLST sequences and profiles were provided, STs will be printed in tab-delim format to a file called \"[outputprefix]__mlst__[db]__results.txt\", e.g.: \"strainArun1__mlst__Escherichia_coli__results.txt\".\r\n\r\nThe format looks like this:\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth\r\n\r\nstrainA     1502    6       63      7       1       14      7       7                       12.3771855735\r\n```\r\n\r\nEach locus has a column in which the best scoring allele number is printed. \r\n\r\n\\* indicates the best scoring allele has >=1 mismatch (SNP or indel, according to majority rules consensus of the aligned reads vs the allele sequence). Details of the mismatches are given in the mismatches column. This often means you have a novel allele. \r\n\r\n? indicates uncertainty in the result because the best scoring allele has some low-depth bases; either the the first or last 2 bases of the allele had <N reads mapped, or a truncation was called in which neigbhbouring bases were coverd with <N reads, or the average depth across the whole allele was <X. N is set by the parameter --min_edge_depth (default 2), X is set by --min_depth (default 5). The source of the uncertainty is printed to the uncertainty column. \r\n\r\n\\- indicates that no allele could be assigned (generally means there were no alleles that were >90% covered by reads) \r\n\r\nIf the combination of these alleles appears in the ST definitions file provided by --mlst_definitions, this ST will be printed in the ST column. \"NF\" indicates the allele combination was not found; \"ND\" indicates ST calculations were not done (because no ST definitions were provided). Here, * next to the ST indicates that there were mismatches against at least one of the alleles. This suggests that you have a novel variant of this ST rather than a precise match to this ST. ? indicates that there was uncertainty in at least one of the alleles. In all cases, the ST is calculated using the best scoring alleles, whether or not there are mismatches or uncertainty in those calls.\r\n\r\nThe *mismatches* column gives details of any mismatches (defined by majority rules consensus of the aligned reads vs the allele sequence) against the top scoring allele that is reported in the corresponding locus column. Possibilities are: (i) snps, adk-1/1snp indicates there was 1 SNP against the adk-1 allele; (ii) indels, adk-1/2indel indicates there were 1 indels (insertion or deletion calls in the alignment); (iii) holes, adk-1/5holes indicates there were 5 sections of the allele sequence that were not covered in the alignment and pileup (e.g. due to truncation at the start or end of the gene, or large deletions within the gene).\r\n\r\nThe *uncertainty* column gives details of parts of the top scoring alleles for which the depth of coverage was too low to give confidence in the result, this may be zero or any number up to the specified cutoff levels set via --min_edge_depth and --min_depth. Possibilities are considered in this order: (i) edge depth, adk-1/edge1.0 indicates that the mean read depth across either the first 2 or last 2 bases of the assigned allele was 1.0; this is monitored particularly because coverage at the ends of the allele sequences is dependent on bowtie2 to properly map reads that overhang the ends of the allele sequences, which is not as confident as when the whole length of a read maps within the gene (reported if this value is below the cutoff specified (default --min_edge_depth 2), low values can be interpreted as indicating uncertainty in the result as we can’t confidently distinguish alleles that differ at these low-covered bases); (ii) truncations, adk-1/del1.0 indicates that a truncation or large deletion was called for which the neighbouring 2 bases were covered to depth 1.0, this can be interpreted as indicating there is only very weak evidence for the deletion, as it is likely just due to random decline in coverage at this point (reported if this value is below the cutoff specified (default --min_edge_depth 2); (iii) average depth, adk-1/depth3.5 indicates that the mean read depth across the length of the assigned allele was 3.5 (reported if this value is below the cutoff specified, which by default is --min_depth 5)\r\n\r\nThe *depth* column indicates the mean read depth across the length of all alleles which were assigned a top scoring allele number (i.e. excluding any which are recorded as '-'). So if there are 7 loci with alleles called, this number represents the mean read depth across those 7 loci. If say, 2 of the 7 alleles were not called (recorded as ‘-’), the mean depth is that of the 5 loci that were called.\r\n\r\n------------\r\n### Gene typing\r\n\r\nGene typing results files report the details of sequences provided in fasta files via --genes_db that are detected above the minimum %coverage theshold set by --min_coverage (default 90).\r\n\r\nTwo output files are produced:\r\n\r\n1 - A detailed report, [outputprefix]__fullgenes__[db]__results.txt, with one row per gene per sample:\r\n\r\n```\r\nSample  DB      gene    allele  coverage        depth   diffs   uncertainty     cluster seqid   annotation\r\n\r\nstrainA     resistance      dfrA    dfrA1_1 100.0   6.79368421053           edge1.5 590     137     \r\n\r\nstrainA     resistance      aadA    aadA1-5 100.0   10.6303797468                   162     1631    \r\n\r\nstrainA     resistance      sul2    sul2_9  100.0   79.01992966                     265     1763    \r\n\r\nstrainA     resistance      blaTEM  blaTEM-1_5      100.0   70.8955916473                   258     1396    \r\n\r\nstrainA     resistance      tet(A)  tet(A)_4        97.6666666667   83.5831202046   28holes edge0.0 76      1208    \r\n\r\nstrainB     resistance      strB    strB1   100.0   90.0883054893                   282     1720    \r\n\r\nstrainB     resistance      strA    strA4   100.0   99.0832298137                   325     1142 \r\n```\r\n\r\n*coverage* indicates the % of the gene length that was covered (if clustered DB, then this is the highest coverage of any members of the cluster)\r\n\r\n*uncertainty* is as above\r\n\r\n2 - A tabulated summary report of samples x genes, [outputprefix]__genes__[db]__results.txt:\r\n\r\n```\r\nSample  aadA    blaTEM  dfrA    strA    strB    sul2    tet(A)\r\n\r\nstrainA     aadA1-5 blaTEM-1_5      dfrA1_1?        -   -   sul2_9  tet(A)_4*?\r\n\r\nstrainB     -     -      -        strA4   strB1   -  -\r\n```\r\n\r\nThe first column indicates the sample name, all other columns report the genes/alleles that were detected in the sample set. If multiple samples were input, or if previous outputs were provided for compiling results, then all the genes detected in ANY of the samples will have their own column in this table.\r\n\r\nIf you were using a clustered gene database (such as the resistance.fasta database provided), the name of each cluster (i.e. the basic gene symbol) will be printed in the column headers, while specific alleles will be printed in the sample rows.\r\n\r\n\\* indicates mismatches\r\n\r\n? indicates uncertainty due to low depth in some parts of the gene\r\n\r\n\\- indicates the gene was not detected (> %coverage threshold, --min_coverage 90)\r\n\r\n------------\r\n### Combined results\r\n\r\nIf more then one database is provided for typing (via --mlst_db and/or --gene_db), or if previous results are provided for merging with the current run which contain data from >1 database (via --prev_output), then an additional table summarizing all the database results is produced. This is named \"[outputprefix]__compiledResults.txt\" and is a combination of the MLST style table plus the tabulated gene summary (file 2 above).\r\n\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth   aadA    blaTEM  dfrA    strA    strB    sul2    tet(A)\r\n\r\nsampleA     152*     11      63*      7       1       14      7       7                       21.3139900892   aadA1-5 blaTEM-1_5      dfrA1_1?        strA4   strB1   sul2_9  tet(A)_4*?\r\n```\r\n\r\n------------\r\n### Mapping results\r\n\r\nThe bowtie2 alignment of reads to each input database is stored in [outputprefix]__[sample].[db].sorted.bam and the samtools pileup of the alignment is stored in [outputprefix]__[sample].[db].pileup. \r\n\r\nIf you used --save_scores, a table of scores for each allele in the database is printed to [outputprefix]__[sample].[db].scores.\r\n\r\n\r\nMore basic usage examples\r\n====\r\n\r\nRun single read sets against MLST database and resistance database\r\n\r\nsrst2 --input_pe pool11_tag2_1.fastq.gz pool11_tag2_2.fastq.gz \r\n\t--output pool11_tag2_Shigella --log \r\n\t--gene_db /vlsci/VR0082/shared/srst2_sep/resistance.fasta \r\n\t--mlst_db Escherichia_coli.fasta \r\n\t--mlst_definitions ecoli.txt\r\n\r\n------------\r\n\r\nRun against multiple read sets in serial\r\n\r\nsrst2 --input_pe *.fastq.gz\r\n\t--output Shigella --log\r\n\t--gene_db /vlsci/VR0082/shared/srst2_sep/resistance.fasta \r\n\t--mlst_db Escherichia_coli.fasta \r\n\t--mlst_definitions ecoli.txt\r\n\r\n------------\r\n\r\nRun against new read sets, merge with previous reports (individual or compiled)\r\n\r\nsrst2 --input_pe strainsY-Z*.fastq.gz\r\n\t--output strainsA-Z --log\r\n\t--gene_db /vlsci/VR0082/shared/srst2_sep/resistance.fasta \r\n\t--mlst_db Escherichia_coli.fasta \r\n\t--mlst_definitions ecoli.txt\r\n\t--prev_output ShigellaA__genes__resistance__results.txt\r\n          ShigellaA__mlst__Escherichia_coli__results.txt\r\n          ShigellaB__genes__resistance__results.txt\r\n          ShigellaB__mlst__Escherichia_coli__results.txt\r\n          ShigellaC-X__compiledResults.txt\r\n\r\n------------\r\n\r\nRun against Enterococcus reads, where read names are different from the usual _1.fastq and _2.fastq\r\n\r\nsrst2 --input_pe strain_R1.fastq.gz strain_R2.fastq.gz \r\n\t--forward _R1 --reverse _R2 \r\n\t--output strainA --log \r\n\t--gene_db /vlsci/VR0082/shared/srst2_sep/resistance.fasta \r\n\t--mlst_db Enterococcus_faecium.fasta \r\n\t--mlst_definitions efaecium.txt\r\n\t\r\nCompile results from completed runs\r\n====\r\n\r\nsrst2 --prev_output *compiledResults.txt --output Shigella_report\r\n \r\nRunning lots of jobs and compiling results\r\n====\r\n\r\nRun against multiple read sets: submitting 1 job per readset to SLURM queueing system.\r\n\r\nThe results from all the separate runs can be compiled together using the above command.\r\n\r\nslurm_srst2.py --script srst2 \r\n\t--output test \r\n\t--input_pe *.fastq.gz \r\n\t--other_args '--gene_db resistance.fasta \r\n\t--mlst_db Escherichia_coli.fasta \r\n\t--mlst_definitions ecoli.txt \r\n\t--save_scores' \r\n\t--walltime 0-1:0 \r\n\t\t> job_sub_list.txt\r\n\r\n------------\r\n\r\nSLURM job script usage options\r\n\r\n```\r\nslurm_srst2.py -h\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  \r\n  --walltime WALLTIME   wall time (default 0-0:30 = 30 minutes)\r\n  \r\n  --memory MEMORY       mem (default 4096 = 4gb)\r\n  \r\n  --rundir RUNDIR       directory to run in (default current dir)\r\n  \r\n  --script SCRIPT       SRST2 script (/vlsci/VR0082/shared/srst2_sep/srst2_150\r\n                        9_reporting2.py)\r\n                        \r\n  --output OUTPUT       identifier for outputs (will be combined with read set\r\n                        identifiers)\r\n                        \r\n  --input_se INPUT_SE [INPUT_SE ...]\r\n                        Single end read file(s) for analysing (may be gzipped)\r\n                        \r\n  --input_pe INPUT_PE [INPUT_PE ...]\r\n                        Paired end read files for analysing (may be gzipped)\r\n                        \r\n  --forward FORWARD     Designator for forward reads (only used if NOT in\r\n                        MiSeq format sample_S1_L001_R1_001.fastq.gz; otherwise\r\n                        default is _1, i.e. expect forward reads as\r\n                        sample_1.fastq.gz)\r\n                        \r\n  --reverse REVERSE     Designator for reverse reads (only used if NOT in\r\n                        MiSeq format sample_S1_L001_R2_001.fastq.gz; otherwise\r\n                        default is _2, i.e. expect forward reads as\r\n                        sample_2.fastq.gz)\r\n                        \r\n  --other_args OTHER_ARGS\r\n                        string containing all other arguments to pass to srst2\r\n```               \r\n                        \r\nKnown issues\r\n====\r\n\r\nReference indexing - srst2 uses bowtie2 for mapping reads to reference sequences. To do this, srst2 must first check the index exists, call bowtie2-build to generate the index if it doesn't already exist, and then call bowtie2 to map the reads to this indexed reference. Occasionallly bowtie2 will return an Error message saying that it doesn't like the index. This seems to be due to the fact that if you submit multiple srst2 jobs to a cluster at the same time, they will all test for the presence of the index and, if index files are present, will proceed with mapping... but this doesn't mean the indexing process is actually finished, and so errors will arise. The simple way out of this is, if you are running lots of srst2 jobs, FIRST index your reference(s) for bowtie2 and samtools (using 'bowtie2-build ref.fasta ref.fasta' and 'samtools faidx ref.fasta'), then submit your srst2 jobs. The slurm_srst2.py script takes care of this by formatting the databases before submitting any srst2 jobs.\r\n\r\nExample - Shigella sonnei public data\r\n====\r\nThis example uses real public data from three Shigella sonnei genomes, two of which were sequenced twice and so allow for reproducibility testing.\r\n\r\nAs Shigella sonnei is a sublineage of E. coli, we must use the E. coli MLST scheme.\r\n\r\nWe will also use the resistance genes database provided with srst2, resistance.fasta (modified from ResFinder).\r\n\r\n### Download the files for the E. coli MLST scheme, using the script provided\r\n\r\n    getmlst.py --species \"Escherichia coli\"\r\n\r\nFor SRST2, remember to check what separator is being used in this allele database\r\n\r\n```\r\nLooks like --mlst_delimiter '-'\r\n\r\nadk-1 --> --> ('adk', '-', '1')\r\n```\r\n\r\nNote, this is correctly guessing that we should use the default --mlst_delimiter '-' with this database. The log file will tell you exactly what files were downloaded.\r\n\r\nCheck that the allele sequences have been downloaded and compiled into a single fasta file: Escherichia_coli#1.fasta\r\n\r\nCheck that the ST definitions have been downloaded: ecoli.txt\r\n\r\n### Download Illumina paired end read sets from the ENA\r\n\r\nNote if you have limited download capacity or time to spare, you could download the first two files only (total ~30MB) for basic testing of srst2.\r\n\r\nstrain 20081885 from ERP000182 (14M, 13M; 51M, 44M)\r\n\r\n```\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024070/ERR024070_1.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024070/ERR024070_2.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR028/ERR028678/ERR028678_1.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR028/ERR028678/ERR028678_2.fastq.gz\r\n```\r\n\r\nstrain 20031275 from ERP000182 (89M, 94M; 88M, 74M)\r\n\r\n```\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024082/ERR024082_1.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024082/ERR024082_2.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR028/ERR028690/ERR028690_1.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR028/ERR028690/ERR028690_2.fastq.gz\r\n```\r\n\r\nstrain IB694 from ERP000182 (80M, 64M)\r\n\r\n```\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024619/ERR024619_1.fastq.gz\r\n\r\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR024/ERR024619/ERR024619_2.fastq.gz\r\n```\r\n\r\n### Try running MLST and gene detection against a tiny read set with low coverage (~3x)\r\n    srst2 --input_pe ERR024070*.fastq.gz --output shigella1 --log --save_scores --mlst_db Escherichia_coli#1.fasta --mlst_definitions ecoli.txt --gene_db resistance.fasta\r\n\r\nNote that, as the databases have not been indexed for bowtie2 yet, that srst2 has to run bowtie2-build which spits out a lot of messages to stdout. This is not a problem!\r\n\r\nBowtie2 also reports its mapping stats, it should indicate that there were only 400,882 reads in this data set, of which 0.02% mapped to our MLST/resistance loci. This probably won't be enough to get good quality information.\r\n\r\nCheck the log file (shigella1.log) to see what happened.\r\n\r\nOutputs are printed to: \r\n\r\nshigella1__mlst__Escherichia_coli#1__results.txt - mlst results only \r\n\r\nshigella1__fullgenes__resistance__results.txt - resistance results, one line per gene\r\n\r\nshigella1__genes__resistance__results.txt - resistance results only, tabulated \r\n\r\nshigella1__compiledResults.txt - MLST and resistance genes, tabulated \r\n\r\nshigella1.ERR024070.Escherichia_coli#1.scores - full score & alignment info for all MLST alleles\r\n\r\nshigella1__ERR024070.resistance.scores - full score & alignment info for resistance genes with >90% coverage\r\n\r\nBecause we ran with the --save_scores flag, we have also got a scores file for each database, which details the score and mapping information for every allele in that database.\r\n\r\nThe ST was not called correctly because depth was too low (average read depth 2.19; this is printed in the MLST result table):\r\n\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth\r\n\r\nERR024070       NF*?    1*?     63*?    7*?     220*?   14*?    7*?     148*?  [mismatches\t[uncertainty]     2.182\r\n```\r\n\r\nOnly 1 resistance gene was detected with >90% coverage (the default threshold), which looks like a variant of strB (marked with * to indicate it was not a precise match, and ? to indicate uncertainty because some bases weren't covered):\r\n\r\n```\r\nSample  strB\r\n\r\nERR024070       strB1*?\r\n```\r\n\r\nThe detailed report in shigella1__fullgenes__resistance__results.txt contains more info: \r\n```\r\nSample  DB      gene    allele  coverage        depth   diffs   uncertainty     cluster seqid   annotation\r\n\r\nERR024070       resistance      strB    strB1   95.1015531661   3.94353826851   3snp41holes     edge0.0 282     1720\r\n```\r\n\r\nIf you look in the scores file (ERR024070.resistance.srst2.pileup.table.scores) you will see that two different alleles of strB were covered >90% (both at 95%) and at low depth (~3.9x). \r\n\r\n```\r\nAllele  Score   Avg_depth       Edge1_depth     Edge2_depth     Percent_coverage        Size    Mismatches      Indels  Truncated_bases DepthNeighbouringTruncation     LeastConfident_Rate     LeastConfident_Mismatches       LeastConfident_Depth    LeastConfident_Pvalue\r\n\r\n282__strB__strB3__1722  1.07   3.94   4.0     0.0     95.10   837     4       0       41      1       1.0     8       8       6.67e-17\r\n\r\n282__strB__strB1__1720  0.82  3.94   4.0     0.0     95.10   837     3       0       41      1       0.33  2       6       0.0007\r\n```\r\n\r\nThe Truncated_bases column shows 41, indicating there were 41 \"holes\" in the alignment of reads to these alleles. The next column, \"DepthNeighbouringTruncation\" contains 1, which tells us that the depth near these holes are 1x, indicating that they are likely to reflect random fluctuation in read depth rather than actual deletions.\r\n\r\nThis shows us that this level of data (which was considered a failed sequencing run) isn't enough to get good results. Luckily this genome was resequenced; let's see what happens when we analyse that data set.\r\n\r\n### Run MLST and gene detection against a proper read set, and compile together with the results from the poor read set for comparison.\r\n\r\n    srst2 --input_pe ERR028678*.fastq.gz --output shigella2 --log --mlst_db Escherichia_coli#1.fasta --mlst_definitions ecoli.txt --gene_db srst/resistance.fasta --prev_output shigella1__compiledResults.txt\r\n\r\nCheck the log file to see what happened.\r\n\r\nOutputs are printed to: \r\n\r\nshigella2__mlst__Escherichia_coli#1__results.txt - mlst results only \r\n\r\nshigella2__fullgenes__resistance__results.txt - resistance results, one line per gene\r\n\r\nshigella2__genes__resistance__results.txt - resistance results only, tabulated \r\n\r\nshigella2__compiledResults.txt - MLST and resistance genes, tabulated\r\n\r\nThis time there is a confident ST called, which should look like this:\r\n\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth\r\n\r\nERR028678       152?    11?     63      7?      1       14      7       7               adk-11/edge2.0;gyrB-7/edge2.0   13.9307395171\r\n```\r\n\r\nThere are also lots of resistance genes identified:\r\n\r\n```\r\nSample  aac(3)-II       aadA    blaCTX-M        blaTEM  dfrA    strA    strB    sul2    tet(A)\r\n\r\nERR028678       aac(3)-IId*     aadA1-5 blaCTX-M-15_23  blaTEM-1_1      dfrA1_1 strA4   strB1   sul2_9  tet(A)_4*?\r\n```\r\n\r\nBecause we supplied a prior results file, shigella2__compiledResults.txt contains the new results as well as the old results.\r\n\r\n```\r\nSample  ST      adk     fumC    gyrB    icd     mdh     purA    recA    mismatches      uncertainty     depth   aac(3)-II       aadA    blaCTX-M        blaTEM  dfrA    strA    strB    sul2    tet(A)\r\n\r\nERR024070       NF*?    1*?     63*?    7*?     220*?   14*?    7*?     148*?   adk-1/1snp106holes;fumC-63/96holes;gyrB-7/2snp80holes;icd-220/1snp129holes;mdh-14/42holes;purA-7/52holes;recA-148/40holes       adk-1/edge0.0;fumC-63/edge0.0;gyrB-7/edge0.0;icd-220/edge0.0;mdh-14/edge1.0;purA-7/edge1.0;recA-148/edge0.0     2.1819729951    -       -       -       -       -       -       strB1*? -       -\r\n\r\nERR028678       152?    11?     63      7?      1       14      7       7       0       adk-11/edge2.0;gyrB-7/edge2.0   13.931  aac(3)-IId*     aadA1-5 blaCTX-M-15_23  blaTEM-1_1      dfrA1_1 strA4   strB1   sul2_9  tet(A)_4*?\r\n```\r\n\r\nNow try running on the other three read sets:\r\n    srst2 --input_pe ERR024082*.fastq.gz ERR028690*.fastq.gz ERR024619*.fastq.gz --output shigella3 --log --mlst_db Escherichia_coli#1.fasta --mlst_definitions ecoli.txt --gene_db srst/resistance.fasta\r\n\r\nNow compile the results from all 5 read sets:\r\n    srst2 --output all --prev_output shigella2__compiledResults.txt shigella3__compiledResults.txt\r\n\r\nThis outputs a file, all__compiledResults.txt, containing the compilation of all results for MLST and resistance genes across the 5 strains.\r\n\r\nGenerating SRST2-compatible clustered database from raw sequences\r\n====\r\n\r\n### Gene database format\r\nIn addition to MLST, srst2 can do gene/allele detection. This works by mapping reads to each of the reference sequences in a fasta file(s) (provided through --gene_db) and reporting details of all genes that are covered above a certain level (--min_coverage, 90% by default). \r\n\r\nIf the input database contains different alelles of the same gene, srst2 can report just the best matching allele for that gene (much like with MLST we report the best matching allele for each locus in the scheme). This makes the output manageable, as you will get one column per gene/locus (e.g. blaCTX-M) which reports the specific allele that was called in each sample (e.g. blaCTX-M-15 in sample A, blaCTX-M-13 in sample B).\r\n\r\nTo do this properly, srst2 needs to know which of the reference sequences are alleles of the same gene. This is done by adhering to the following format in the naming of the sequences (i.e. the headers in the fasta sequence for the database):\r\n\r\n\\>[clusterUniqueIdentifier]__[clusterSymbol]__[alleleSymbol]__[alleleUniqueIdentifier]\r\n\r\ne.g. in the resistance gene database provided, the first entry is:\r\n\r\n\\>344__blaOXA__blaOXA-181__1\r\n\r\nNote these are separated by two underscores. The individual components are:\r\n\r\nclusterUniqueIdentifier = 344;  unique identifier for this cluster (uniquely identifes the cluster)\r\nclusterSymbol = blaOXA;  gene symbol for this cluster (may be shared by multiple clusters)\r\nalleleSymbol = blaOXA-181;  full name of this allele\r\nalleleUniqueIdentifier = 1;  uniquely identifies the sequence\r\n\r\nIdeally the alleleSymbol would be unique (as it is in the reference.fasta file provided). However it doesn't have to be: if allele symbols are not unique, then srst2 will use the combination '[alleleSymbol]__[alleleUniqueIdentifier]' to  uniquely identify the sequence in the resulting reports, so that you can trace exactly which sequence was present in each sample.\r\n\r\nAdditional gene annotation can appear on the header line, after a space. This additional info will be printed in the full genes report, but not in the compiled results files.\r\n\r\ne.g. for the blaOXA sequence above, the full header is actually:\r\n\r\n\\>344__blaOXA__blaOXA-181__1 blaOXA-181_1_HM992946; HM992946; betalactamase\r\n\r\n\r\n### Sourcing suitable gene databases\r\n\r\nTo get started, we have provided a resistance gene database (data/resistance.fasta) and code (database_clustering/) to extract virulence factors for a genus of interest from the Virulence Factor DB (detailed instructions below).\r\n\r\nIf you want to use your own database of allele sequences, with the reporting behaviour described, you will need to assign your sequences to clusters and use this header format. To facilitate this, use the scripts provided in the database_clustering directory provided with srst2, and follow the instructions below.\r\n\r\nYou can also use unclustered sequences. This is perfectly fine for gene detection applications, where you have one representative allele sequence for each gene, and you simply want to know which samples contain a sequence that is similar to this one (e.g. detecting plasmid replicons, where there is one target sequence per replicon). However, this won't work well for allele typing. If the sequence database contains multiple allele sequences for the same gene, then all of these that are covered above the length threshold (default 90%) will be reported in the output, which makes for messy reporting. If you do this, you would probably find it most useful to look at the full gene results table rather than looking at the compiled results output.\r\n\r\n### If you already know which alleles belong to the same gene family and should be clustered for reporting:\r\n\r\nUse this info to generate the appropriate headers for srst2 to read. The provided script, csv_to_gene_db.py can help:\r\n\r\n```\r\ncsv_to_gene_db.py -h\r\n\r\nUsage: csv_to_gene_db.py [options]\r\n\r\nOptions:\r\n\r\n  -h, --help            show this help message and exit\r\n  \r\n  -t TABLE_FILE, --table=TABLE_FILE\r\n                        table to read (csv)\r\n                        \r\n  -o OUTPUT_FILE, --out=OUTPUT_FILE\r\n                        output file (fasta)\r\n                        \r\n  -s SEQ_COL, --seq_col=SEQ_COL\r\n                        column number containing sequences\r\n                        \r\n  -f FASTA_FILE, --fasta=FASTA_FILE\r\n                        fasta file to read sequences from (must specify which\r\n                        column in the table contains the sequence names that\r\n                        match the fasta file headers)\r\n                        \r\n  -c HEADERS_COL, --headers_col=HEADERS_COL\r\n                        column number that contains the sequence names that\r\n                        match the fasta file headers\r\n                        \r\n```\r\n\r\nThe input table should be comma-separated (csv, unix newline characters) and have these columns:\r\n\r\nseqID,clusterid,gene,allele,(DNAseq),other....\r\n\r\nwhich will be used to make headers of the required form [clusterID]__[gene]__[allele]__[seqID] [other stuff]\r\n\r\nIf you have the sequences as a column in the table, specify which column they are in using -s:\r\ncsv_to_gene_db.py -t genes.csv -o genes.fasta -s 5\r\n\r\nAlternatively, if you have sequences in a separate fasta file, you can provide this file via -f. You will also need to have a column in the table that links the rows to unique sequences, specify which column this is using -c:\r\ncsv_to_gene_db.py -t genes.csv -o genes.fasta -f rawseqs.fasta -c 5\r\n\r\n\r\n### Clustering sequences\r\n\r\nIf your sequences are not already assigned to gene clusters, you can do this automatically using CD-HIT (http://weizhong-lab.ucsd.edu/cd-hit/).\r\n\r\n1 - Run CD-HIT to cluster the sequences at 90% nucleotide identity:\r\n\r\n    cdhit-est -i rawseqs.fasta -o rawseqs_cdhit90 -d 0 > rawseqs_cdhit90.stdout\r\n\r\n2 - Parse the cluster output and tabulate the results, check for inconsistencies between gene names and the sequence clusters, and generate individual fasta files for each cluster to facilitate further checking:\r\n\r\n    python cdhit_to_csv.py --cluster_file rawseqs_cdhit90.clstr --infasta raw_sequences.fasta --outfile rawseqs_clustered.csv\r\n\r\nFor comparing gene names to cluster assignments, this script assumes very basic nomenclature of the form gene-allele, ie a gene symbol followed by '-' followed by some more specific allele designation. E.g. adk-1, blaCTX-M-15. The full name of the gene (adk-1, blaCTX-M-15) will be stored as the allele, and the bit before the '-' will be stored as the name of the gene cluster (adk, blaCTX). This won't always give you exactly what you want, because there really are no standards for gene nomenclature! But it will work for many cases, and you can always modify the script if you need to parse names in a different way. Note though that this only affects how sensible the gene cluster nomenclature is going to be in your srst2 results, and will not affect the behaviour of the clustering (which is purely sequence based using cdhit) or srst2 (which will assign a top scoring allele per cluster, the cluster name may not be perfect but the full allele name will always be reported anyway).\r\n\r\n3 - Convert the resulting csv table to a sequence database using:\r\n\r\n    csv_to_gene_db.py -t rawseqs_clustered.csv -o seqs_clustered.fasta -f rawseqs.fasta -c 4\r\n\r\nThe output file, seqs_clustered.fasta, should now be ready to use with srst2 (--gene_db seqs_clustered.fasta).\r\n\r\nIf there are potential inconsistencies detected at step 2 above (e.g. multiple clusters for the same gene, or different gene names within the same cluster), you may like to investigate further and change some of the cluster assignments or cluster names. You may find it useful to generate neighbour joining trees for each cluster that contains >2 genes, using align_plot_tree_min3.py\r\n\r\n### Screening for resistance genes with SRST2\r\nA preliminary set of resistance genes is in the /data directory of srst2, this is based on the ResFinder database and CARD. The fasta file is ready for use with SRST2. The CSV table contains the same sequence information, but in tabular format for easier parsing/editing.\r\n\r\nAn easy way to add sequences to this database would be to add new rows to the table, and then generate an updated fasta file using:\r\n\r\n    csv_to_gene_db.py -t rawseqs_clustered.csv -o seqs_clustered.fasta -s rawseqs.fasta -c 5\r\n\r\n### Using the VFBD Virulence Factor Database with SRST2\r\n\r\nThe VFDB houses sets of virulence genes for a range of bacterial genera, see http://www.mgc.ac.cn/VFs/.\r\n\r\nTo type these virulence genes using SRST2, download the full set of sequences from the VFDB website (http://www.mgc.ac.cn/VFs/Down/CP_VFs.ffn.gz) and follow these steps to generate SRST2-compatible files for your genus of interest.\r\n\r\n1 - Extract virulence genes by genus from the main VFDB file, CP_VFs.ffn:\r\n\r\n    python VFDBgenus.py --infile CP_VFs.ffn --genus Clostridium\r\n\r\nor, to get all availabel genera in separate files:\r\n\r\n    python VFDBgenus.py --infile CP_VFs.ffn\r\n\r\n2 - Run CD-HIT to cluster the sequences for this genus, at 90% nucleotide identity:\r\n\r\n    cd-hit -i Clostridium.fsa -o Clostridium_cdhit90 -c 0.9 > Clostridium_cdhit90.stdout\r\n\r\n3 - Parse the cluster output and tabulate the results using the specific Virulence gene DB compatible script:\r\n\r\n    python VFDB_cdhit_to_csv.py --cluster_file Clostridium_cdhit90.clstr --infile Clostridium.fsa --outfile Clostridium_cdhit90.csv\r\n\r\n4 - Convert the resulting csv table to a SRST2-comptaible sequence database using:\r\n\r\n    python csv_to_gene_db.py -t Clostridium_cdhit90.csv -o Clostridium_VF_clustered.fasta -s 5\r\n    \r\nThe output file, Clostridium_VF_clustered.fasta, should now be ready to use with srst2 (--gene_db Clostridium_VF_clustered.fasta).\r\n","google":"UA-44427590-1","note":"Don't delete this file! It's used internally to help with page regeneration."}